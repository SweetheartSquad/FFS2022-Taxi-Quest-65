::start
<<if !this.started>>
<<do
	// blinking and lip flaps
	this.blinking = false;
	this.timeoutBlinking;
	// this.scene.dialogue.scripts.push({
	// 	gameObject: this.scene.dialogue,
	// 	update: () => {
	// 		if (!this.character) return;
	// 		if (!this.timeoutBlinking) {
	// 			this.timeoutBlinking = setTimeout(() => {
	// 				this.blinking = !this.blinking;
	// 				this.timeoutBlinking = null;
	// 			}, this.blinking ? 100 : 2000+Math.random()*4000);
	// 		};

	// 		const letter = this.scene.dialogue.strText[scene.dialogue.pos];
	// 		const isLetter = letter && letter.replace(/[^\w]/, '');
	// 		if (isLetter) {
	// 			this.scene.dialogue.toggler.active.setAnimation(`portrait_${this.character}_${this.face}_open`);
	// 		} else if (this.blinking && this.character !== 'tsade') {
	// 			this.scene.dialogue.toggler.active.setAnimation(`portrait_${this.character}_${this.face}_blink`);
	// 		} else {
	// 			this.scene.dialogue.toggler.active.setAnimation(`portrait_${this.character}_${this.face}`);
	// 		}
	// 	},
	// });

	// portrait helper
	// this.portrait = (character, face, options) => {
	// 	this.character = character;
	// 	this.face = (face || 'normal')
	// 		.trim()
	// 		.replace(':)', 'normal')
	// 		.replace(':O', 'o')
	// 		.replace('>_>', 'side')
	// 		.replace(':(', 'sad');
	// 	const result = this.show(character ? `portrait_${this.character}_${this.face}` : character, { scale: 2, x: -128+47, y: 126, duration: 500, ...options });
	// };

	// automatically hide portrait on close
	// and stop roam during dialogues
	// this.scene.dialogue.openo = this.scene.dialogue.open;
	// this.scene.dialogue.open = () => {
	// 	if (scene.areas.main) {
	// 		scene.areas.main.filter(i => i.roam).forEach(i => i.roam.active = false);
	// 	}
	// 	this.scene.dialogue.openo();
	// };
	// this.scene.dialogue.closeo = this.scene.dialogue.close;
	// this.scene.dialogue.close = () => {
	// 	this.portrait();
	// 	if (scene.areas.main) {
	// 		scene.areas.main.filter(i => i.roam).forEach(i => i.roam.active = true);
	// 	}
	// 	this.scene.dialogue.closeo();
	// };

	// add syntax sugar for passages like `Daydiem :O : "Blah blah"`
	// const check = /(Daydiem|Rexty|Tsade|MC)\s*(.*?)\s*:\s*"/;
	// this.scene.dialogue.sayo = this.scene.dialogue.say;
	// this.scene.dialogue.say = (text, actions) => {
	// 	const match = check.exec(text);
	// 	if (match) {
	// 		this.portrait(match[1].toLowerCase(), match[2]);
	// 		requestAnimationFrame(() => this.scene.dialogue.pos = match[1].length+2);
	// 		this.scene.dialogue.sayo(`${match[1]}:\n"${text.substring(match[0].length)}`, actions);
	// 	} else {
	// 		this.scene.dialogue.sayo(text, actions);
	// 	}
	// };


	// text helper
	// this.texttimeouts = [];
	// this.PText = (text, delay = 0, offset = 0) => {
	// 	const timeout = setTimeout(() => {
	// 		this.sfx('voiceDefault');
	// 		const t = this.Text(text, { x: player.transform.x, y: player.transform.y - 20 + offset, offset: this.texttimeouts.length * 100 });
	// 		t.scripts[1].container.children[0].anchor.x = 0.5;
	// 		this.add(t);
	// 	}, delay);
	// 	this.texttimeouts.push(timeout);
	// };

	// start
	this.started=true;
	requestAnimationFrame(() => {
		this.scrim(1, 3000);
		this.scene.dialogue.sprBg.alpha = 0;
	});
>>
<<endif>>
<<do
	this.show('title2', { scale: 2, duration: 0, y: 126/2 });
>>
TAXI QUEST 65
>START
<<do
	this.music('bgm');
	this.show('').then(() => {this.goto('start2')});
>>

::start2
<<do
	this.tween(this.scene.border.display.container, 'alpha', 1, 5000);
	this.tween(this.scene.dialogue.sprBg, 'alpha', 1, 5000, 0);;
	this.goto('main');
>>

::close
this should never render

::The End
TODO
>
<<do
	this.show('black', { scale: 512 });
	this.tween(this.scene.border.display.container, 'alpha', 0, 1000);
	this.tween(this.scene.dialogue.sprBg, 'alpha', 0, 1000);
	this.tween(scene.camera.display.container, 'alpha', 0, 1000);
>>
>
<<do
	this.show('title', { scale: 2, y: 126/2 });
>>
<<print new Array(60).fill('\u200B').join('')>>
The End

[[Restart|this.restart()]]

::debug menu
[[passage select>passage select]]
[[close]]
[[back|this.back()]]

::main
<<do this.scrim(0.25, 1000)>>
TODO

